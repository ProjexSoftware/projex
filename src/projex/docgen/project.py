#!/usr/bin/python

""" Parses through the python source code to generate HTML documentation.  """

# define authorship information
__authors__         = ['Eric Hulser']
__author__          = ','.join(__authors__)
__credits__         = []
__copyright__       = 'Copyright (c) 2011, Projex Software'
__license__         = 'LGPL'

# maintanence information
__maintainer__      = 'Projex Software'
__email__           = 'team@projexsoftware.com'

#------------------------------------------------------------------------------

import datetime
import distutils.dir_util
import logging
import inspect
import os
import pkgutil
import shutil
import sys
import time

from xml.etree import ElementTree

import projex
import projex.text

from projex.docgen.renderers import Renderer
from projex.docgen.pages import *

from projex.enum import enum
logger = logging.getLogger(__name__)

COMPANY = 'Projex Software'
COMPANY_URL = 'http://www.projexsoftware.com'
COPYRIGHT = 'generated by <a href="http://www.projexsoftware.com">docgen</a> '\
            'coyright &copy; <a href="{domain}">{company}</a> {year}'

#----------------------------------------------------------------------

class DoxProject(object):
    def __init__(self, **kwds):
        # custom properties
        self._filename = ''
        self._currentFormat = 'html'
        self._pages = []
        self._properties = {}
        self._folders = []
        self._environ = {}
        
        self._preview = False
        self._theme = kwds.get('theme', 'default')
        self._company = kwds.get('company', '')
        self._companyDomain = kwds.get('companyDomain', '')
        self._title = kwds.get('title', 'Documentation')
        self._version = kwds.get('version', '0.0')
        self._copyright = kwds.get('copyright', '')

    def basepath(self):
        """
        Returns the basepath for this project.
        
        :return     <str>
        """
        fname = self.filename()
        if fname:
            return os.path.dirname(fname)
        return ''

    def create(self, filename=''):
        """
        Creates a new project at the given filename.
        
        :param      filename | <str>
        """
        if not self.save(filename):
            return

        filename = self.filename()
        basepath = os.path.dirname(filename)
        
        # create the project folders
        os.mkdir(os.path.join(basepath, 'pages'))
        os.mkdir(os.path.join(basepath, 'resources'))
        os.mkdir(os.path.join(basepath, 'resources', 'img'))
        os.mkdir(os.path.join(basepath, 'resources', 'themes'))
        
        # duplicate the default themes for the project
        themepath = os.path.join(os.path.dirname(__file__), 'themes')
        for theme in os.listdir(themepath):
            src = os.path.join(themepath, theme)
            targ = os.path.join(basepath, 'resources', 'themes', theme)
            distutils.dir_util.copy_tree(src, targ)

    def children(self):
        """
        Returns a combination of the child pages and folders for this
        folder instance, sorted by their sort order.
        
        :return     [<DoxFolder> || <DoxPage>, ..]
        """
        out = self.rootfolders() + self.rootpages()
        out.sort(key=lambda x: x.order())
        return out

    def createPage(self, title, **options):
        """
        Creates a new wiki page for the project.
        
        :return     <DoxPage>
        """
        options['title'] = title
        page = DoxPage(self, **options)
        self._pages.append(page)
        return page

    def createFolder(self, title, **options):
        """
        Creates a new folder for the project.
        
        :return     <DoxPage>
        """
        options['title'] = title
        folder = DoxFolder(self, **options)
        self._folders.append(folder)
        return folder

    def company(self):
        """
        Returns the company associated with this project.
        
        :return     <str>
        """
        if not self._company:
            return COMPANY
        return self._company

    def companyDomain(self):
        """
        Returns the company domain associated with this project.
        
        :return     <str>
        """
        if not self._companyDomain:
            return COMPANY_URL
        return self._companyDomain

    def copyright(self):
        """
        Returns the copyright associated with this project.
        
        :return     <str>
        """
        if not self._copyright:
            return COPYRIGHT.format(company=self.company(),
                                    domain=self.companyDomain(),
                                    year=datetime.date.today().year)
        
        return self._copyright

    def currentFormat(self):
        """
        Returns the current format based on the active renderer.
        
        :return     <str>
        """
        return self._currentFormat

    def currentExtension(self):
        try:
            return Renderer._plugins[self.currentFormat()].extension()
        except KeyError:
            return '.html'

    def defaultpage(self):
        """
        Returns the default page associated with this folder.
        
        :return     <DoxPage> || None
        """
        first = None
        for page in sorted(self.rootpages(), key=lambda x: x.order()):
            if not first:
                first = page

            if page.filename('html') in ('__init__.html', 'index.html'):
                return page
        
        return first

    def export(self, outpath='', format='html', **options):
        """
        Exports the project to the given filepath in the export format.
        
        :param      outpath | <str>
                    format  | <str>
                    options | Renderer options
        
        :return     <bool> | success
        """
        if not outpath and self.filename():
            outpath = os.path.join(os.path.dirname(self.filename()), 'dist')
            if os.path.exists(outpath):
                try:
                    shutil.rmtree(outpath)
                except:
                    pass

        if not outpath:
            return False
        
        renderer = self.renderer(format)
        if not renderer:
            return False
        
        self._currentFormat = format
        renderer.setOptions(options)
        return renderer.export(outpath)

    def filename(self):
        """
        Returns the filename for this project.
        
        :return     <str>
        """
        return self._filename

    def findPageFromFilepath(self, filepath):
        """
        Looks for a page based on the given filepath.
        
        :param      filepath | <str>
        
        :return     (<DoxPage> page, <str> scope)
        """
        basepath = self.basepath()
        filepath = os.path.normpath(os.path.splitext(str(filepath))[0])
        filepath = filepath.lower()
        
        for page in self.pages():
            for scope in page.scopes():
                fname = page.filepath(scope=scope)
                test = os.path.normpath(os.path.splitext(fname)[0])
                test = test.lower()
                
                fulltest = os.path.normpath(os.path.join(basepath, test))
                fulltest = fulltest.lower()
                
                if filepath in (test, fulltest):
                    return (page, scope)
        
        return (None, '')

    def folder(self, name):
        """
        Returns the folder with the given name if found.
        
        :return     <DoxFolder> || None
        """
        for folder in self._folders:
            if folder.folderName() == name:
                return folder
        return ''

    def folders(self):
        """
        Returns a list of all the folders for this project.
        
        :return     [<DoxFolder>, ..]
        """
        return self._folders

    def inspectModule(self, module, parent=None, path='', order=0):
        """
        Inspects a given module for data.
        
        :param      module | <str> || <module>
        
        :return     <ModuleInspector> || None
        """
        # merge a module
        if type(module) in (str, unicode):
            # merge from a particular location
            if path:
                if path.startswith('.'):
                    path = os.path.abspath(os.path.join(self.basepath(), path))
                
                try:
                    sys.path.remove(path)
                except ValueError:
                    pass
                
                sys.path.insert(0, path)
            
            try:
                __import__(module)
                module = sys.modules.get(module)
            except:
                return []
        
        # check if this module is a package
        filename = inspect.getfile(module)
        inspected = ModuleInspector(self,
                                    module,
                                    parent=parent,
                                    sourcefile=filename)
        
        output = [inspected]
        
        self._pages.append(inspected)
        basename = module.__name__
        basepath = os.path.dirname(filename)
        opts = []
        for importer, modname, ispkg in pkgutil.iter_modules([basepath]):
            opts.append((not ispkg, modname))
        
        opts.sort()
        for _, modname in opts:
            output += self.inspectModule(basename + '.' + modname,
                                         parent=inspected)
        
        return output

    def inspectClasses(self, modules, parent=None):
        processed = set()
        output = []
        
        module_names = map(lambda x: x.pageName(), modules)
        
        def _inspect_class(cls):
            # ensure the module is within our scope
            if cls.__module__ in module_names:
                key = '.'.join((cls.__module__,
                                cls.__name__))
                
                if key in processed:
                    return
                
                processed.add(key)
                mod_parent = self.page(cls.__module__)
                if mod_parent:
                    try:
                        module_file = sys.modules[cls.__module__].__file__
                    except (KeyError, AttributeError):
                        module_file = ''
                    
                    if module_file.endswith('.pyc'):
                        module_file = module_file[:-1]
                    
                    cls_page = ClassInspector(self,
                                              cls,
                                              parent=parent,
                                              sourcefile=module_file)
                    
                    # otherwise, add it to the process
                    output.append(cls_page)
                    self._pages.append(cls_page)
            
            # inspect the base classes
            for base in cls.__bases__:
                _inspect_class(base)
        
        # load all the packages within the given path
        for page in modules:
            for member in page.members():
                if member.kind != 'Class':
                    continue
                
                _inspect_class(member.object)
        
        output.sort(key=lambda x: x.title())
        for i in range(len(output)):
            output[i].setOrder(i)
        
        return output

    def isPreviewMode(self):
        """
        Returns whether or not the rendering for this project is in preview
        mode.
        
        :return     <bool>
        """
        return self._preview

    def loadXmlPage(self, xpage, parent=None, order=0):
        """
        Loads the XML information from the inputed page to this project.
        
        :param      xpage  | <xml.etree.ElementTree.Element>
                    parent | <DoxPage> || <DoxFolder> || None
        """
        if xpage.tag == 'folder':
            folder = self.createFolder(xpage.get('title'),
                                       parent=parent,
                                       order=order)
            
            for i, xchild in enumerate(xpage):
                self.loadXmlPage(xchild, folder, order=i)
        
        elif xpage.tag == 'inspect':
            folder = DoxFolder(self, title=xpage.get('name'), parent=parent)
            folder.setModulePath(xpage.get('path'))
            folder.setOrder(order)
            folder.setModule(xpage.get('module'))
            
            # create the module reference
            modref = DoxFolder(self, title='Modules', parent=folder)
            mods = self.inspectModule(xpage.get('module'),
                                      parent=modref,
                                      path=xpage.get('path'))
            
            # create the class reference
            classref = DoxFolder(self, title='Classes', parent=folder)
            classes = self.inspectClasses(mods, parent=classref)
            
            self._folders.append(folder)
            self._folders.append(modref)
            self._folders.append(classref)

        else:
            self.createPage(xpage.get('title'),
                            pageName=xpage.get('name'),
                            sourcefile=xpage.get('source'),
                            parent=parent,
                            order=order)

    def page(self, name):
        """
        Returns an page that has been created for the inputed object.
        
        :param      name | <str>
        
        :return     <projex.docgen.DoxPage> || None
        """
        for page in self._pages:
            if page.pageName() == name:
                return page
        return None

    def pages(self, cls=None):
        """
        Returns a list of the pages for the given inspector class
        associated with this project.
        
        :return     [<projex.docgen.DoxPage>, ..]
        """
        if not cls:
            return self._pages
        return filter(lambda x: isinstance(x, cls), self._pages)

    def path(self, name, format=''):
        """
        Returns the default custom path to the inputed name
        
        :param      name | <str>
        """
        if not format:
            format = self.currentFormat()
        
        basepath = self.basepath()
        themepath = self.themepath(format)
        
        # determine the static path
        if self.isPreviewMode():
            staticpath = os.path.join(basepath, 'resources')
        else:
            staticpath = os.path.join(basepath, '_static')
        
        if ':' in name:
            section, _, name = name.partition(':')
        else:
            return ''

        # return a static file
        if section == 'static':
            return os.path.join(staticpath, name).replace('\\', '/')

        # return a css file from the theme
        elif section == 'css':
            if self.isPreviewMode():
                return os.path.join(themepath, 'css', name).replace('\\', '/')
            else:
                return os.path.join(staticpath, self.theme(), 'css', name).replace('\\', '/')

        # return a js file from the theme
        elif section == 'js':
            if self.isPreviewMode():
                return os.path.join(themepath, 'js', name).replace('\\', '/')
            else:
                return os.path.join(staticpath, self.theme(), 'js', name).replace('\\', '/')

        # return an image file from the theme
        elif section == 'img':
            if self.isPreviewMode():
                return os.path.join(themepath, 'img', name).replace('\\', '/')
            else:
                return os.path.join(staticpath, self.theme(), 'img', name).replace('\\', '/')

        # return a template file from the theme
        elif section == 'templ':
            return os.path.join(themepath, 'templ', name).replace('\\', '/')

        # return no valid path
        return ''

    def property(self, name, default=None):
        """
        Returns the property for the given name.
        
        :param      name    | <str>
                    default | <variant>
        
        :return     <variant>
        """
        return self._properties.get(str(name), default)

    def removePage(self, page):
        """
        Removes the inputed page from this project.
        
        :param      page | <DoxPage>
        """
        try:
            self._pages.remove(page)
        except ValueError:
            pass

    def removeFolder(self, folder):
        """
        Removes the inputed page from this project.
        
        :param      page | <DoxPage>
        """
        try:
            self._folders.remove(folder)
        except ValueError:
            return

        for child in folder.children():
            if isinstance(child, DoxFolder):
                self.removeFolder(child)
            else:
                self.removePage(child)
        
    def renderer(self, format):
        """
        Returns a renderer for this project based on the inputed format.
        
        :param      format | <str>
        
        :return     <projex.docgen.Renderer> || None
        """
        return Renderer.create(self, format)

    def renderers(self):
        """
        Returns the available renderers for the project.
        
        :return     [<str>, ..]
        """
        return sorted(Renderer._plugins.keys())

    def rootfolders(self):
        """
        Returns a list of the root folders for this project.
        
        :return     [<DoxFolder>, ..]
        """
        return filter(lambda x: x.parent() == None, self._folders)

    def rootpages(self):
        """
        Returns a list of the pages whose folder is not defined.
        
        :return     [<DoxPage>, ..]
        """
        return filter(lambda x: x.folder() == None, self._pages)

    def save(self, filename=''):
        """
        Saves this project out to the given filename.
        
        :param      filename | <str>
        """
        if not filename:
            filename = self.filename()
        
        if not filename:
            return False
        
        xml = self.toXml()
        projex.text.xmlindent(xml)
        try:
            tree = ElementTree.ElementTree(xml)
            tree.write(filename)
        except:
            return False
        
        self._filename = filename
        return True

    def setCurrentFormat(self, format):
        """
        Sets the renderer format to the inputed text.
        
        :param      format | <str>
        """
        self._currentFormat = format

    def setPreviewMode(self, state):
        """
        Sets whether or not the rendering for this project is in preview mode.
        
        :return     <bool>
        """
        self._preview = state

    def setProperty(self, name, value):
        """
        Sets the property for the given name to the inputed value.
        
        :param      name | <str>
                    value | <variant>
        """
        self._properties[str(name)] = value
    def setTheme(self, theme):
        """
        Sets the current theme to use while rendering.
        
        :param      theme | <str>
        """
        self._theme = theme

    def subfolders(self, parent):
        """
        Returns a list of the sub-folders linked with the inputed folder.
        
        :return     [<DoxFolder>, ..]
        """
        return filter(lambda x: x.parent() == parent, self._folders)

    def subpages(self, parent):
        """
        Returns a list of the sub-pages linked with the inputed folder page.
        
        :return     [<DoxPage>, ..]
        """
        return filter(lambda x: x.parent() == parent, self._pages)

    def template(self, name):
        """
        Returns the template associated with this project based on the current
        theme.
        
        :param      name | <str>
        
        :return     <str> | filename
        """
        return self.path('templ:{0}'.format(name))

    def theme(self):
        """
        Returns the theme associated with this project.
        
        :return     <str>
        """
        return self._theme

    def themes(self):
        """
        Returns the available themes for the project.
        
        :return     [<str>, ..]
        """
        themepath = os.path.join(self.basepath(), 'resources', 'themes')
        paths = [themepath]
        paths += os.environ.get('DOX_THEMEPATH', '').split(os.path.pathsep)
        
        output = set()
        for path in paths:
            if not (path and os.path.exists(path)):
                continue
            
            for folder in os.listdir(path):
                output.add(folder)
        
        return list(output)

    def themepath(self, format='', theme=''):
        """
        Returns the theme path location for this project.
        
        :return     <str>
        """
        if not theme:
            theme = self.theme()
        
        if not format:
            format = self.currentFormat()
        
        paths = []
        
        basepath = self.basepath()
        basepath = os.path.join(basepath, 'resources', 'themes')
        
        instpath = os.path.dirname(__file__)
        instpath = os.path.join(instpath, 'themes')
        
        paths.append(basepath)
        paths += os.environ.get('DOX_THEMEPATH', '').split(os.path.pathsep)
        paths.append(instpath)
        
        for path in paths:
            if not path:
                continue
            
            themepath = os.path.join(path, theme, format)
            if os.path.exists(themepath):
                return themepath
        
        return ''
        
    def title(self):
        """
        Returns the title associated with this project.
        
        :return     <str>
        """
        return self._title

    def toXml(self):
        """
        Stores this project as XML information.
        
        :return     <xml.etree.ElementTree.Element>
        """
        xml = ElementTree.Element('dox')
        xml.set('version', '2.0')
        
        # save config info
        data = {}
        data['copyright'] = self._copyright
        data['title'] = self._title
        data['company'] = self._company
        data['companyDomain'] = self._companyDomain
        data['theme'] = self._theme
        data['version'] = self._version
        
        # save environment information
        xenv = ElementTree.SubElement(xml, 'environ')
        for key, value in self._environ.items():
            xvar = ElementTree.SubElement(xenv, key)
            xvar.text = value
        
        # save config information
        xconfig = ElementTree.SubElement(xml, 'config')
        for key, value in data.items():
            xattr = ElementTree.SubElement(xconfig, key)
            xattr.text = value
        # save property information
        xprops = ElementTree.SubElement(xml, 'properties')
        for key, value in self._properties.items():
            xprop = ElementTree.SubElement(xprops, key)
            xprop.text = str(value)

        # save page information
        xpages = ElementTree.SubElement(xml, 'pages')
        for child in self.children():
            child.toXml(xpages)

        return xml

    def toc(self, format=''):
        """
        Returns the table of contents for this project.
        
        :return     <xml.etree.ElementTree.Element>
        """
        if not format:
            format = self.currentFormat()
        
        xml = ElementTree.Element('toc')
        xml.set('version', '2.0')
        
        xitem = ElementTree.SubElement(xml, 'item')
        ext = self.currentExtension()
        xitem.set('title', self.title())
        try:
            xitem.set('url', self.defaultpage().filepath(extension=ext))
        except AttributeError:
            pass
        
        for child in self.children():
            child.toc(xitem, self.currentExtension())
        
        return xml

    def version(self):
        """
        Returns the version of the documentation for this project.
        
        :return     <str>
        """
        return self._version

    @staticmethod
    def fromXml(xml, filename=''):
        """
        Restores the project from the inputed xml data.
        
        :param      xml | <xml.etree.ElementTree.Element>
        
        :return     <DoxProject>
        """
        proj = DoxProject()
        proj._filename = filename
        
        # restore environment
        xenv = xml.find('environ')
        if xenv is not None:
            for xvar in xenv:
                text = xvar.text if xvar.text else ''
                proj._environ[xvar.tag] = text
                
                # add the python path to the environment
                if xvar.tag == 'PYTHONPATH' and text:
                    sys.path += map(os.path.expandvars, text.split(';'))
        
        # restore configuration details
        xconfig = xml.find('config')
        if xconfig is not None:
            for xattr in xconfig:
                setattr(proj, '_' + xattr.tag, xattr.text)

        # restore properties
        xprops = xml.find('properties')
        if xprops is not None:
            for xprop in xprops:
                proj.setProperty(xprop.tag, xprop.text)

        # save page information
        xpages = xml.find('pages')
        if xpages is not None:
            for i, xchild in enumerate(xpages):
                proj.loadXmlPage(xchild, order=i)
        
        return proj

    @staticmethod
    def load(filename):
        """
        Loads the project information from the XML filename.
        
        :param      filename | <str>
        
        :return     <DoxProject> || None
        """
        try:
            xml = ElementTree.parse(filename).getroot()
        except:
            return None

        proj = DoxProject.fromXml(xml, filename)
        path = os.path.join(os.path.dirname(filename), 'helpers')
        if not path in sys.path:
            sys.path.append(path)
        
        return proj


